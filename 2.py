# Воронина Татьяна КН-304
# Лабораторная работа 2
# Вариант 3
# f(x) = 1 + sin(x) - 1.12e^(-x)
# точность Е = 0.5 * 10^(-5)
#
# TODO Буду писать ответы вот так, чтобы подсвечивались
# TODO f - функция, f_ - первая производная, f__ - вторая производная

import math


def func(x):
    """
    метод который находит значение функции в точке x
    """
    return 1 + math.sin(x) - 1.12 * math.exp(-x)


def func_(x):
    """
    метод который находит значение производной функции в точке x
    """
    return math.cos(x) + 1.12 * math.exp(-x)


def func__(x):
    """
    метод который находит значение 2 производной функции в точке x
    """
    return (-1) * math.sin(x) - 1.12 * math.exp(-x)


E = 0.5 * (10 ** (-5))  # точность

"""
выбор отрезка [a, b]
сделаем перебор иксов от -5 до +5
и посмотрим, где значение функции в соседних почках имеют разные знаки
на этом отрезке и будет лежать корень уравнения
"""
tek = -5
ans = []
for x in range(-4, 5 + 1):
    if func(x) * func(tek) < 0:
        ans = [tek, x]
        break
    else:
        tek = x
print(f'Отрезок на котором есть корень [a, b] = {ans}')
# TODO Отрезок на котором есть корень [a, b] = [0, 1]

"""
выбор точки для методов 2-5
"""
a, b = 0, 1
print(
    f'точка -> {a}, '
    f'производная -> {func(a)}, '
    f'2 производная -> {func__(a)}, '
    f'f__(a) * f(a) -> {func(a) * func__(a)}, '
    f'{func(a) * func__(a) > 0}'
)
print(
    f'точка -> {b}, '
    f'производная -> {func(b)}, '
    f'2 производная -> {func__(b)}, '
    f'f__(b) * f(b) -> {func(b) * func__(b)}, '
    f'{func(b) * func__(b) > 0}'
)
# TODO точка -> 0, производная -> -0.1200000000000001, 2 производная -> -1.12, f__(a) * f(a) -> 0.13440000000000013, True
# TODO точка -> 1, производная -> 1.429446010695881, 2 производная -> -1.253495958919912, f__(b) * f(b) -> -1.7918047979014762, False
# TODO выбираем точку 0
print()
"""
1. Метод половинного деления
суть метода:
- определить середину отрезка [a, b] (b+a)/2
- вычислить погрешность |b-a| и завершить, если < E
- найти знак функции в точках a, (b+a)/2, b
- если это 0, то корень найден, если нет, то берем отрезок, где разные знаки
- повторяем алгоритм до нужного приближения корня
"""
a, b = 0, 1
ans = 0
i = 0
while (b - a) / 2 > E:
    i += 1
    c = (a + b) / 2
    if func(c) == 0:
        ans = c  # точный корень
    elif func(c) * func(a) < 0:
        b = c
    else:
        a = c
if ans == 0:
    ans = (a + b) / 2
print(f'1. Метод половинного деления: корень -> {round(ans, 7)}, количество итераций -> {i}')
# TODO 1. Метод половинного деления: корень -> 0.057476, количество итераций -> 17

"""
2. Метод Ньютона
- вычисляем значение функции и ее производной в х
- подсчитываем х(+1) = х - (f(x)/f_(x))
- продолжаем, пока не достигнем погрешности
"""
i = 0
x = 0
while abs(func(x) / func_(x)) > E:
    i += 1
    x -= func(x) / func_(x)
print(f'2. Метод Ньютона: корень -> {round(x, 7)}, количество итераций -> {i}')
# TODO 2. Метод Ньютона: корень -> 0.057475, количество итераций -> 2

"""
3. Модифицированный метод Ньютона
Различие в том, что f_(x_n) заменятеся на f_(x_0)
"""
i = 0
x = 0
while abs(func(x) / func_(0)) > E:
    i += 1
    x -= func(x) / func_(0)
print(f'3. Модифицированный метод Ньютона: корень -> {round(x, 7)}, количество итераций -> {i}')
# TODO 3. Модифицированный метод Ньютона: корень -> 0.057474, количество итераций -> 3

"""
4. Метод хорд
аналогично итерируемся пока не достигнем приближения
теперь используем такую формулу для вычисления следующего приближения
x_n1 = x_n - (f(x_n) / (f(x_n) - f(y))) * (x_n - y)
y - предыдущее приближение к корню
"""
x, y = 0, 1
i = 0
while abs(func(x) / func_(x)) > E:
    i += 1
    x -= (func(x) * (x - y)) / (func(x) - func(y))
print(f'4. Метод хорд: корень -> {round(x, 7)}, количество итераций -> {i}')
# TODO 4. Метод хорд: корень -> 0.057473, количество итераций -> 10

"""
5. Метод подвижных хорд
аналогично методу хорд, но здесь меняем обо конца отрезка
"""
x, y = 0, 1
i = 0
while abs(func(x) / func_(x)) > E:
    temp = x
    i += 1
    x -= (func(x) * (x - y)) / (func(x) - func(y))
    y = temp
print(f'5. Метод подвижных хорд: корень -> {round(x, 7)}, количество итераций -> {i}')
# TODO 5. Метод подвижных хорд: корень -> 0.0574731, количество итераций -> 3

"""
6. Метод простой итерации
"""
"""
как определила функцию.
выразила х из синуса
х = arcsin(1.12 * e^(-х) - 1)
производная 
f_(x) = -3 / sqrt(150 * e^x -9)
ниже считала от точек, чтобы понять, подходит или нет.
она должна быть по модулю меньше 1
"""


def MPE_f(x):
    """
    значение функции в точке х
    """
    return math.asin(1.12 * math.exp(-x) - 1)


def MPE_f_(x):
    """
    значение производной функции в точке х
    """
    return 3 / math.sqrt(150 * math.exp(x) - 9)


a, b = 0, 1
print()
print(
    f'точка -> {a}, '
    f'производная -> {MPE_f(a)}, '
    f'{abs(MPE_f(a)) < 1}'
)
print(
    f'точка -> {b}, '
    f'производная -> {MPE_f(b)}, '
    f'{abs(MPE_f(b)) < 1}'
)
# TODO точка -> 0, производная -> 0.12028988239478818, True
# TODO точка -> 1, производная -> -0.6285531237767326, True

i = 0
x = 0
while abs(func(x) / func_(x)) > E:
    print('*', abs(func(x) / func_(x)))
    i += 1
    x = MPE_f(x)
    print(x)
print(f'6. Метод простой итерации: корень -> {round(x, 7)}, количество итераций -> {i}')
# TODO 6. Метод простой итерации: корень -> 0.057474, количество итераций -> 7

"""
сравним скорости сходимости предложенных методов
такой вывод я получила

1. Метод половинного деления: корень -> 0.057476, количество итераций -> 17
2. Метод Ньютона: корень -> 0.0574746, количество итераций -> 2
3. Модифицированный метод Ньютона: корень -> 0.057474, количество итераций -> 3
4. Метод хорд: корень -> 0.057473, количество итераций -> 10
5. Метод подвижных хорд: корень -> 0.0574731, количество итераций -> 3
6. Метод простой итерации: корень -> 0.057474, количество итераций -> 7
"""
