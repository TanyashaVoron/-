'''
Воронина Татьяна КН-304
Лабораторная работа 3
Вариант 3

    ( −0.10 1.00 0.10 )
A = ( 1.51 −0.20 0.40 )
    ( −0.30 −0.10 −0.50 )

    ( 2.20 )
B = ( 2.31 )
    ( −2.00 )

Решить систему линейных уравнений вида Ax = B, используя точные и итерационные
методы:
1. Метод Гаусса;
2. Метод Якоби;
3. Метод Гаусса-Зейделя.
В отчете:
• Для методов 2, 3 проверить сходимость метода (в том числе при перестановке уравнений
местами); в случае сходимости найти решение с точностью 0.5·10−4
; сравнить количество итераций.
'''

import numpy as np

# буду использовать библиотеку numpy ( надо прописать в консоли - pip install numpy)

# напишу в виде массивов
A = np.array([[-0.10, 1.00, 0.10], [1.51, -0.20, 0.40], [-0.30, -0.10, -0.50]])
B = np.array([[2.20], [2.31], [-2.00]])


def gauss_elimination(A, B):
    # Объединяем матрицы A и B
    AB = np.column_stack((A, B))

    # Прямой ход
    for i in range(len(AB)):
        # Находим максимальный элемент в текущем столбце
        max_index = np.argmax(np.abs(AB[i:, i])) + i
        # Меняем строки местами
        AB[[i, max_index]] = AB[[max_index, i]]

        # Делаем элемент на диагонали равным 1
        AB[i] /= AB[i, i]

        # Обнуляем элементы под и над диагональю
        for j in range(i + 1, len(AB)):
            AB[j] -= AB[j, i] * AB[i]

    # Обратный ход
    for i in range(len(AB) - 1, 0, -1):
        for j in range(i - 1, -1, -1):
            AB[j] -= AB[j, i] * AB[i]

    return AB[:, -1]


# Решаем систему методом Гаусса
solution = gauss_elimination(A, B)

print(f'Решение системы уравнений методом Гаусса: x1 = {solution[0]}, x2 = {solution[1]}, x3 = {solution[2]}')
# Решение системы уравнений методом Гаусса: x1 = 1.0, x2 = 2.0, x3 = 3.0

"""
сделаем проверку
-0.1 + 2 + 0.3 = 2.2 (верно)
1.51 - 0.4 + 1.2 = 2.31 (верно)
-0.3 - 0.2 - 1.5 = -2 (верно)
"""

"""
проверим на сходимость

1) Диагональное преобладание: |-0.1| > |1| + |0.1| - НЕТ
однако, если переставить строки местами и сделать матрицу 
[1.51, -0.20, 0.40],
[-0.10, 1.00, 0.10], 
[-0.30, -0.10, -0.50]
тогда диагональное преобладание будет
"""
A = np.array([[1.51, -0.20, 0.40], [-0.10, 1.00, 0.10], [-0.30, -0.10, -0.50]])
B = np.array([[2.31], [2.20], [-2.00]])

"""
Метод Якоби.

В методе Якоби матрицу A можно представить в виде суммы трех матриц: 
диагональной (D),
нижнетреугольной (-L),
верхнетреугольной (-U). 
Таким образом, A = D - L - U.

Итерационный процесс метода Якоби выглядит следующим образом:
x^(k+1) = D^(-1) * (b + (L + U) * x^(k))
где x^(k+1) - новое приближенное решение,
x^(k) - текущее приближенное решение,
D^(-1) - обратная диагональная матрица,
L и U - соответственно нижнетреугольная и верхнетреугольная матрицы,
полученные из разложения A = D - L - U.
"""


def jacobi_method(A, B, tolerance=0.00005, max_iterations=100000):
    n = len(A)
    X = np.zeros_like(B)  # Начальное приближение

    # Проверка условия сходимости
    eigenvalues, _ = np.linalg.eig(A)
    if np.all(np.abs(eigenvalues) < 1):
        print("Метод Якоби сходится.")

    iterations = 0
    while iterations < max_iterations:
        X_new = np.copy(X)
        for i in range(n):
            sigma = sum(A[i, j] * X[j] for j in range(n) if j != i)
            X_new[i] = (B[i] - sigma) / A[i, i]

        if np.linalg.norm(X_new - X) < tolerance:
            print(f"Метод Якоби сошелся с точностью 0.00005 за {iterations} итераций.")
            return X_new, iterations

        X = np.copy(X_new)
        iterations += 1

    print(f"Метод Якоби не сошелся за {max_iterations} итераций.")
    return None, iterations


# Задаем матрицу A и вектор B (уравнения мы переставили местами, чтобы было диагональное преобладание)
A = np.array([[1.51, -0.20, 0.40], [-0.10, 1.00, 0.10], [-0.30, -0.10, -0.50]])
B = np.array([[2.31], [2.20], [-2.00]])

# Решаем систему методом Якоби
solution, num_iterations = jacobi_method(A, B)

if solution is not None:
    print(
        f'Решение системы уравнений методом Якоби: x1 = {solution[0][0]}, x2 = {solution[1][0]}, x3 = {solution[2][0]}'
    )
# Метод Якоби сошелся с точностью 0.00005 за 13 итераций
# Решение системы уравнений методом Якоби: x1 = 0.9999952840150551, x2 = 1.9999989420133117, x3 = 2.9999955326473775


"""
Метод Гаусса-Зейделя
для него аналогично нужна диагональная сходимость. мы помним, что для этого переставили уравнения местами !!!

Итерационный процесс Гаусса-Зейделя записывается следующим образом:
x^(k+1)_i = (b_i - sum(A[i, j] * x^(k)_j for j in range(i)) - sum(A[i, j] * x^(k+1)_j for j in range(i+1, n))) / A[i, i]

где x^(k+1)_i - новое приближенное значение переменной на i-той позиции,
x^(k)_j - текущее приближенное значение переменной на j-той позиции,
A[i, j] - элемент матрицы коэффициентов A на позиции (i, j),
b_i - элемент вектора правых частей B на позиции i.

продолжается до достижения заданной точности или максимального числа итераций.
"""

"""
Для начала проверим сходимость.
на практике говорили, что диагональное преобладание нельзя использовать, тогда 
должно быть |AL + AD + R| = 0
A - лямбда

буду использовать сразу переставленную местами матрицу
строим матрицу

[1.51*A, -0.20, 0.40],
[-0.10*A, 1.00*A, 0.10], 
[-0.30*A, -0.10*A, -0.50*A]

посчитаем определитель
(1.51*A)*(1.00*A)*(-0.50*A)+(-0.10*A)*(0.40)*(-0.10*A)+(-0.30*A)*(-0.20)*(0.10)
A = 0.0918344152028208
A = 0.0
A = -0.0865364019577877

они по модулю меньше 1 -> метод сходится 
"""


def gauss_seidel(A, b, tolerance=0.00005):
    n = len(A)
    x = np.zeros(n)
    iterations = 0

    converge = False
    while not converge:
        iterations += 1
        x_new = np.copy(x)
        for i in range(n):
            s1 = np.sum(np.fromiter((A[i, j] * x_new[j] for j in range(i)), float))
            s2 = np.sum(np.fromiter((A[i, j] * x[j] for j in range(i + 1, n)), float))
            x_new[i] = (b[i] - s1 - s2) / A[i, i]

        converge = np.sqrt(np.sum((x_new[i] - x[i]) ** 2 for i in range(n))) <= tolerance
        x = x_new

    print(f"Метод Гаусса-Зейделя сошелся с точностью 0.00005 за {iterations} итераций")
    return x


# Задаем матрицу A и вектор B (уравнения мы переставили местами, чтобы было диагональное преобладание)
A = np.array([[1.51, -0.20, 0.40], [-0.10, 1.00, 0.10], [-0.30, -0.10, -0.50]], dtype=float)
B = np.array([2.31, 2.20, -2.00], dtype=float)

solution = gauss_seidel(A, B)
print(
    f'Решение системы уравнений методом Гаусса-Зейделя: x1 = {solution[0]}, x2 = {solution[1]}, x3 = {solution[2]}'
)
# Метод Гаусса-Зейделя сошелся с точностью 0.00005 за 9 итераций
# Решение системы уравнений методом Гаусса-Зейделя: x1 = 1.0000052524481728, x2 = 2.0000020629951623, x3 = 2.999996435932064


"""
Итоговый вывод программы

Решение системы уравнений методом Гаусса: x1 = 1.0, x2 = 2.0, x3 = 3.0
Метод Якоби сошелся с точностью 0.00005 за 13 итераций.
Решение системы уравнений методом Якоби: x1 = 0.9999952840150551, x2 = 1.9999989420133117, x3 = 2.9999955326473775
Метод Гаусса-Зейделя сошелся с точностью 0.00005 за 9 итераций
Решение системы уравнений методом Гаусса-Зейделя: x1 = 1.0000052524481728, x2 = 2.0000020629951623, x3 = 2.999996435932064

Можно сделать вывод, что метод Гаусса-Зейделя эффективней метода Якоби
"""
